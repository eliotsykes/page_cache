PageCache
=========

Holeless page caching plugin for Rails.

Inspired by the Pivotal Labs "Rails, Slashdotted: no problem" article:
http://pivotallabs.com/users/steve/blog/articles/262-rails-slashdotted-no-problem

With this plugin, users never have to wait for cached pages to be generated
(unlike the page caching that ships with Rails).

You can safely use this plugin alongside Rails' existing page caching mechanism
as it does not interfere with it.

The page cache is populated by a rake task before deployment
completes.  The page cache can optionally be 'holelessly' expired and refreshed
while the app is running.

The holeless/seamless caching works by having two cache stages, that exist as 
two distinct directories.

The cache stages are "latest" and "live".

The "latest" stage/directory contains the most recently generated cached files.
When a cached file is created, it is written to the "latest" directory. Apache 
does *not* serve anything from the "latest" cache directory.

"live" contains the cached files that *are* served by Apache.  After a cached
file is written to the latest directory, it is then copied, then that copy is 
moved to the live directory, (holelessly) overwriting the previously cached file.
Moving the newly cached file in this way is intended to provide the
seamless/holeless cache, a user is only ever served a cached file, never a dynamically
generated file.

**PLEASE NOTE** This plugin works in production for my simple needs, but 
if you use it, be sure it is doing what you expect it to and placing the cached
files where you need them. You are responsible for ensuring your web server 
(often Apache) serves the static cached files when needed. Some rewrite rules 
are given in the example further below for you to use or modify for your own
environment's needs.

Rails version support
=====================
The Page Cache plugin is known to work with Rails 2.2.x, and I suspect is likely
to work on other versions with minimal/no tweaking.  If you tweak it, submit
your changes back to the project via Github for others to benefit from your work.

Example
=======

In config/environments/production.rb (and config/environments/development.rb if
you want to manually test page caching), ensure these configuration options are
set:

config.cache_classes = true
config.action_controller.perform_caching = true

In your ApplicationController (application_controller.rb), include the
PageCache::PageCaching module.

class ApplicationController < ActionController::Base
  include PageCache::PageCaching
  
  ...

In a controller where you want to use page caching, e.g. PostsController:

class PostsController < ApplicationController
  # Simple page caching
  cached_pages :some_action, :another_action
  
  # The posts page is cached, but will be expired if the PostPublishedEvent
  # or PostDeleteEvent occur. For the :expires_on to have any affect, you
  # will need to ensure these events are passed on to 
  # PageCache::CachedPage.handle_event(event). More info below.
  cached_pages :list,
    { :expires_on => [ PostPublishedEvent, PostArchivedEvent ] }
  
  def some_action
  end
  
  def another_action
  end
  
  def list
  end
end

Set up rewrite rules like the following in your .htaccess, replacing wherever it
says example.tld with your domain, e.g. mywonderfulapp.com:

# Turn rewriting engine on
RewriteEngine on

# Serve files from live cache directory if available

# Home page
RewriteCond %{HTTP_HOST} ^(.+)\.example.tld$
RewriteCond %{DOCUMENT_ROOT}/cache/live/%1/index.html -f
RewriteRule ^$ cache/live/%1/index.html [QSA,PT,L]

# Non home page
RewriteCond %{HTTP_HOST} ^(.+)\.example.tld$
RewriteCond %{DOCUMENT_ROOT}/cache/live/%1/%{REQUEST_URI} -f
RewriteRule ^(.*)$ cache/live/%1/$1 [QSA,PT,L]

I strongly recommend testing that these rewrite rules work for your environment,
they may need tweaking.

When you deploy, using capistrano, call
'rake page_cache:update'.

To update your cache periodically, call rake page_cache:update in cron, being
sure to supply the correct RAILS_ENV argument e.g.
'rake page_cache:update RAILS_ENV=production'. Note this will only update the
page cache if cached files have been expired using the CachedPage#expire method.
The CachedPage#expire method is called when the :expires_on events happen.

***OPTIONAL :expires_on usage START***
*If* you use the :expires_on array option with the cached_pages method as shown
in the 2nd example above, then you will need to ensure events are passed to
the PageCache::CachedPage.handle_event(event) method. One suggestion is to create
a simple EventMulticaster class in your app, like so:

class EventMulticaster
  def self.publish(event)
    PageCache::CachedPage.handle_event(event)
  end
end

Create event classes like these:

class PostPublishedEvent
  def self.fire
    EventMulticaster.publish self.new
  end
end

When a new Post is published, then you would fire the PostPublishedEvent like so:

PostPublishedEvent.fire

The event would be received by CachedPage.handle_event(event) and this would
result in the expected cached files being expired/deleted.
***OPTIONAL :expires_on usage END***


Contributions welcome.

I know you've got something better to do, but next time you're waiting for a
test run to complete, perhaps consider checking out my other projects at:
http://blog.eliotsykes.com/my-projects/

Copyright (c) 2010 Eliot Sykes, released under the MIT license

